# === @begin: Headers Configuration ===
# By default, it's an empty string, but we still must define it otherwise `configure_file` will fail.
# In theory, one who builds this package may define that to unique value to be used in a `nccl` version string.
# We, however, don't do that in Eugo environment and keep it mostly for compatability with original Makefile builds.
set(NCCL_SUFFIX "")

# Define a directory where we will place the configured (generated by filling placeholders in `nccl.h.in` file) `nccl.h` header file.
# And other headers that may be generated in the future.
set(CONFIGURED_HEADERS_DIR "${CMAKE_CURRENT_BINARY_DIR}/include")
file(MAKE_DIRECTORY "${CONFIGURED_HEADERS_DIR}")

configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/nccl.h.in
    ${CONFIGURED_HEADERS_DIR}/nccl.h
)
# NOTE: this is the NVIDIA_ORIGINAL and just for documentation purposes.
# We can't place this in `nccl.h.in` file b/c it causes errors, so leaving it here for reference
# #define NCCL_MAJOR ${nccl:Major}
# #define NCCL_MINOR ${nccl:Minor}
# #define NCCL_PATCH ${nccl:Patch}
# #define NCCL_SUFFIX "${nccl:Suffix}"
#
# #define NCCL_VERSION_CODE ${nccl:Version}
# === @end: Headers Configuration ===


# === @begin: device/ ===
add_subdirectory(device)
# === @end: device/ ===


# === @begin: `libnccl` library ===
set(NCCL_SRC_FILES
    # === @begin: ./ (`@/src/CMakeLists.txt`) ===
    allocator.cc
    bootstrap.cc
    ce_coll.cc
    channel.cc
    collectives.cc
    debug.cc
    dev_runtime.cc
    # enhcompat.cc # only used with `libcudart_static.a` and intended for its old versions support. Current implementation looks extremely dangerous as it overrides the `cudart` symbols w/ its "crashing" stubs.
    enqueue.cc
    group.cc
    init.cc
    init_nvtx.cc
    mnnvl.cc
    proxy.cc
    sym_kernels.cc
    transport.cc
    # === @end: ./ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./misc/ (`@/src/CMakeLists.txt`) ===
    misc/argcheck.cc
    misc/cudawrap.cc
    misc/gdrwrap.cc
    misc/ibvsymbols.cc
    misc/ibvwrap.cc
    misc/ipcsocket.cc
    misc/mlx5dvsymbols.cc
    misc/mlx5dvwrap.cc
    misc/nvmlwrap.cc
    misc/param.cc
    misc/shmutils.cc
    misc/socket.cc
    misc/strongstream.cc
    misc/utils.cc
    # === @end: ./misc/ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./plugin/ ===
    # === @@begin: `@/src/plugin/CMakeLists.txt` ===
    plugin/net.cc
    plugin/plugin_open.cc
    plugin/profiler.cc
    plugin/tuner.cc
    # === @@end: `@/src/plugin/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/net/CMakeLists.txt` ===
    plugin/net/net_v6.cc
    plugin/net/net_v7.cc
    plugin/net/net_v8.cc
    plugin/net/net_v9.cc
    plugin/net/net_v10.cc
    plugin/net/net_v11.cc
    # === @@end: `@/src/plugin/net/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/profiler/CMakeLists.txt` ===
    plugin/profiler/profiler_v1.cc
    plugin/profiler/profiler_v2.cc
    plugin/profiler/profiler_v3.cc
    plugin/profiler/profiler_v4.cc
    plugin/profiler/profiler_v5.cc
    # === @@end: `@/src/plugin/profiler/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/tuner/CMakeLists.txt` ===
    plugin/tuner/tuner_v2.cc
    plugin/tuner/tuner_v3.cc
    plugin/tuner/tuner_v4.cc
    plugin/tuner/tuner_v5.cc
    # === @@end: `@/src/plugin/tuner/CMakeLists.txt` ===
    # === @end: ./plugin/ ===


    # === @begin: ./transport/ (`@/src/transport/CMakeLists.txt`) ===
    transport/coll_net.cc
    transport/generic.cc
    transport/net_ib.cc
    transport/net_socket.cc
    transport/net.cc
    transport/nvls.cc
    transport/p2p.cc
    transport/profiler.cc
    transport/shm.cc
    # === @end: ./transport/ (`@/src/transport/CMakeLists.txt`) ===


    # === @begin: ./graph/ ===
    # === @begin: Private Header Files ===
    # @TODO: probably we should refactor that into `target_include_directories()`
    # Upstream implementation doesn't include these boys explicitely, but it works as they are stored in the same folder, but we want to be explicit and not rely on an accident in our build.
    graph/rings.h
    graph/topo.h
    graph/xml.h
    # === @@end: Private Header Files ===

    # === @@begin: Source Files (`@/src/graph/CMakeLists.txt`) ===
    graph/connect.cc
    graph/paths.cc
    graph/rings.cc
    graph/search.cc
    graph/topo.cc
    graph/trees.cc
    graph/tuning.cc
    graph/xml.cc
    # === @@end: Source Files (`@/src/graph/CMakeLists.txt`) ===
    # === @end: ./graph/ ===


    # === @begin: ./register/ (`@/src/register/CMakeLists.txt`) ===
    register/coll_reg.cc
    register/register.cc
    register/sendrecv_reg.cc
    # === @end: ./register/ (`@/src/register/CMakeLists.txt`) ===


    # === @begin: ./ras (`@/src/ras/CMakeLists.txt`) ===
    # In the same directory they store both files for the `libnccl` portion of `ras` symbols and source for `ncclras` executable.
    # In our original version, we accidentally used them all to build `ncclras` that led to undefined symbol errors at runtime.
    ras/client_support.cc
    ras/collectives.cc
    ras/peers.cc
    ras/ras.cc
    ras/rasnet.cc
    # === @end: ./ras (`@/src/ras/CMakeLists.txt`) ===


    # === @begin: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===
    nccl_device/core.cc
    nccl_device/ll_a2a.cc
    nccl_device/mem_barrier.cc
    # === @end: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===


    # === @begin: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===
    scheduler/symmetric_sched.cc
    # === @end: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===
)

add_library(nccl SHARED ${NCCL_SRC_FILES})


target_compile_definitions(
    nccl
    PUBLIC
        ${NCCL_COMMON_COMPILE_DEFINITIONS}
)


# @NVIDIA_ORIGINAL: @begin:
# @EUGO_CHANGE:
# We preserved this snippet as they rely on `CUDA_MAJOR` and `CUDA_MINOR` definitions in their code.
# To avoid collisions due to generic macro names used we renamed them into more standartized `CUDAToolkit_VERSION_MAJOR` and `CUDAToolkit_VERSION_MINOR`, respectively, set automatically by CMake after running `find_package(CUDAToolkit ...)`.
# We also mark them `PRIVATE` to avoid leakage to downstream packages if we'd need different treatment for these macros.
#
# Add CUDA version definitions after find_package
target_compile_definitions(
    nccl
    PRIVATE
        CUDAToolkit_VERSION_MAJOR=${CUDAToolkit_VERSION_MAJOR}
        CUDAToolkit_VERSION_MINOR=${CUDAToolkit_VERSION_MINOR}
)
# @NVIDIA_ORIGINAL: @end


# `WHOLE_ARCHIVE` is needed as `nccl_colldevice` is a static library and we want to get all its symbols!
target_link_libraries(nccl PRIVATE "$<LINK_LIBRARY:WHOLE_ARCHIVE,nccl_colldevice>")


# @Important:
# We couldn't use `NCCL_DEPENDENCIES` list here, as `cudart` is used in `nccl` interface while `cccl` is a header-only library only used as an implementation detail, so they must go into different section to avoid breaking downstream packages build failures or runtime UB!
target_link_libraries(
    nccl
    PRIVATE CCCL::libcudacxx
    INTERFACE CUDA::cudart
)


set_target_properties(
    nccl
    PROPERTIES
        VERSION ${NCCL_VERSION}
        SOVERSION ${NCCL_MAJOR}
)


target_include_directories(
    nccl
    PUBLIC
        $<BUILD_INTERFACE:${CONFIGURED_HEADERS_DIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/plugin>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)


# Only nccl.h and nccl_net.h are public headers and only they are installed!
set(NCCL_PUBLIC_HEADERS
    ${CONFIGURED_HEADERS_DIR}/nccl.h
    ${CMAKE_CURRENT_SOURCE_DIR}/include/plugin/nccl_net.h
    PARENT_SCOPE
)
# === @end: `libnccl` library ===


# === @begin: ras/ ===
add_subdirectory(ras)
# === @end: ras/ ===
