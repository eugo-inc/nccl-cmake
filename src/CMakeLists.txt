# === @begin: Headers Configuration ===
# By default, it's an empty string, but we still must define it otherwise `configure_file` will fail.
# In theory, one who builds this package may define that to unique value to be used in a `nccl` version string.
# We, however, don't do that in Eugo environment and keep it mostly for compatability with original Makefile builds.
set(NCCL_SUFFIX "")

# Define a directory where we will place the configured (generated by filling placeholders in `nccl.h.in` file) `nccl.h` header file.
# And other headers that may be generated in the future.
set(CONFIGURED_HEADERS_DIR "${CMAKE_CURRENT_BINARY_DIR}/include")
file(MAKE_DIRECTORY "${CONFIGURED_HEADERS_DIR}")

configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/nccl.h.in
    ${CONFIGURED_HEADERS_DIR}/nccl.h
)
# NOTE: this is the NVIDIA_ORIGINAL. We can't place this in `nccl.h.in` file b/c it causes errors, so leaving it here for reference
# #define NCCL_MAJOR ${nccl:Major}
# #define NCCL_MINOR ${nccl:Minor}
# #define NCCL_PATCH ${nccl:Patch}
# #define NCCL_SUFFIX "${nccl:Suffix}"
#
# #define NCCL_VERSION_CODE ${nccl:Version}

# === @end: Headers Configuration ===


# === @begin: device/ ===
add_subdirectory(device)
# === @end: device/ ===


# === @begin: nccl library ===
set(NCCL_SRC_FILES
    # === @begin: ./ (`@/src/CMakeLists.txt`) ===
    allocator.cc
    bootstrap.cc
    ce_coll.cc
    channel.cc
    collectives.cc
    debug.cc
    dev_runtime.cc
    # enhcompat.cc - only used with `libcudart_static.a` and intended for its old versions support. Current implementation looks extremely dangerous as it overrides the `cudart` symbols w/ its "crashing" stubs.
    enqueue.cc
    group.cc
    init.cc
    init_nvtx.cc
    mnnvl.cc
    proxy.cc
    sym_kernels.cc
    transport.cc
    # === @end: ./ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./misc/ (`@/src/CMakeLists.txt`) ===
    misc/argcheck.cc
    misc/cudawrap.cc
    misc/gdrwrap.cc
    misc/ibvsymbols.cc
    misc/ibvwrap.cc
    misc/ipcsocket.cc
    misc/mlx5dvsymbols.cc
    misc/mlx5dvwrap.cc
    misc/nvmlwrap.cc
    misc/param.cc
    misc/shmutils.cc
    misc/socket.cc
    misc/strongstream.cc
    misc/utils.cc
    # === @end: ./misc/ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./plugin/ ===
    # === @@begin: `@/src/plugin/CMakeLists.txt` ===
    plugin/net.cc
    plugin/plugin_open.cc
    plugin/profiler.cc
    plugin/tuner.cc
    # === @@end: `@/src/plugin/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/net/CMakeLists.txt` ===
    plugin/net/net_v6.cc
    plugin/net/net_v7.cc
    plugin/net/net_v8.cc
    plugin/net/net_v9.cc
    plugin/net/net_v10.cc
    plugin/net/net_v11.cc
    # === @@end: `@/src/plugin/net/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/profiler/CMakeLists.txt` ===
    plugin/profiler/profiler_v1.cc
    plugin/profiler/profiler_v2.cc
    plugin/profiler/profiler_v3.cc
    plugin/profiler/profiler_v4.cc
    plugin/profiler/profiler_v5.cc
    # === @@end: `@/src/plugin/profiler/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/tuner/CMakeLists.txt` ===
    plugin/tuner/tuner_v2.cc
    plugin/tuner/tuner_v3.cc
    plugin/tuner/tuner_v4.cc
    plugin/tuner/tuner_v5.cc
    # === @@end: `@/src/plugin/tuner/CMakeLists.txt` ===
    # === @end: ./plugin/ ===


    # === @begin: ./transport/ (`@/src/transport/CMakeLists.txt`) ===
    transport/coll_net.cc
    transport/generic.cc
    transport/net_ib.cc
    transport/net_socket.cc
    transport/net.cc
    transport/nvls.cc
    transport/p2p.cc
    transport/profiler.cc
    transport/shm.cc
    # === @end: ./transport/ (`@/src/transport/CMakeLists.txt`) ===


    # === @begin: ./graph/ ===
    # === @begin: Private Header Files ===
    # @HELP: probably we should refactor that into `target_include_directories()`
    # Upstream implementation doesn't include these boys explicitely, but it works as they are stored in the same folder, but we want to be explicit and not rely on an accident in our build.
    graph/rings.h
    graph/topo.h
    graph/xml.h
    # === @@end: Private Header Files ===

    # === @@begin: Source Files (`@/src/graph/CMakeLists.txt`) ===
    graph/connect.cc
    graph/paths.cc
    graph/rings.cc
    graph/search.cc
    graph/topo.cc
    graph/trees.cc
    graph/tuning.cc
    graph/xml.cc
    # === @@end: Source Files (`@/src/graph/CMakeLists.txt`) ===
    # === @end: ./graph/ ===


    # === @begin: ./register/ (`@/src/register/CMakeLists.txt`) ===
    register/coll_reg.cc
    register/register.cc
    register/sendrecv_reg.cc
    # === @end: ./register/ (`@/src/register/CMakeLists.txt`) ===


    # === @begin: ./ras (`@/src/ras/CMakeLists.txt`) ===
    # In the same directory they store both files for the `libnccl` portion of `ras` symbols and source for `ncclras` executable.
    # In our original version, we accidentally used them all to build `ncclras` that led to undefined symbol errors at runtime.
    ras/client_support.cc
    ras/collectives.cc
    ras/peers.cc
    ras/ras.cc
    ras/rasnet.cc
    # === @end: ./ras (`@/src/ras/CMakeLists.txt`) ===


    # === @begin: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===
    nccl_device/core.cc
    nccl_device/ll_a2a.cc
    nccl_device/mem_barrier.cc
    # === @end: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===


    # === @begin: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===
    scheduler/symmetric_sched.cc
    # === @end: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===
)

add_library(nccl SHARED ${NCCL_SRC_FILES})
target_link_libraries(nccl PRIVATE nccl_colldevice)
# rt pthread dl - @HELP: we probably shouldn't link them explicitely on latest `glibc`
# @HELP: EXTRA_LIBS
# @HELP: figure out which exact CUDAToolkit_LIBRARIES this boy depends on as they simply link them ... ALL which is definitely an overkill

set_target_properties(
    nccl
    PROPERTIES
        VERSION ${NCCL_VERSION}
        SOVERSION ${NCCL_MAJOR}
)

# @HELP: should we replace `$<BUILD_INTERFACE:${CONFIGURED_HEADERS_DIR}>` and `$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>` by simply `${INCEXPORTS}` or something similar? As they are public ones
target_include_directories(
    nccl
    PUBLIC
        $<BUILD_INTERFACE:${CONFIGURED_HEADERS_DIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/plugin>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)


# @HELP(today) -> replace with proper target_link_libraries() - looks like this guy depends not only on `cudart` as to make CUDA work as a language but they also consume low-level functions from here directly.
# Analogy: `cudart` is a dual-nature/-purpose library:
# 1. `cudart` is like `libc++abi` & `libunwind` in that it's always linked by the `clang` if C++ code is built even if no C++ standard library functions are invoked.
# 2. `cudart` is like `libc++` which provides actual implementations of C++ standard library functions. This may be not added by linker as a dependency if no `std::` symbols are used.
# For instance, we can link `libstdc++` as C++ stdlib implementation while using `libc++abi` and `libunwind` AND other way round we can use `libc++` as a C++ stdlib together w/ `libgcc_s`.
#
# In most cases, we link only against `cudart` and do it implicitly (via `clang++` for CUDA) - i.e., we don't invoke `find_package(CUDAToolkit ...)` to use it as the actual code that uses its symbols (to interoperate w/ a driver) is not written by us but emitted by `clang++` (or `nvcc` as they work in the same way).
# E.g., `clang++`/`nvcc` calls `cudart` functions to submit the `cubin` stored in the current binary into the CUDA driver for execution and gets the results back.
# However, if we use `cudart` symbols explicitly in our own code and not the `clang++`-emitted one (like in `native/cuda_nccl`), we should explicitely express this dependency.
#
# In practice, I don't think exist the cases where we only want to use the inplicit `cudart` linkage as almost always when we invoke the device kernel, we need to talk w/ the driver explicitely - e.g., to pass the data to the device as this operation is always explicit and not emitted by the kernel itself (as kernel defines that happens on device).
#
# target_include_directories(
#     nccl
#     PUBLIC
#         ${CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES}
# )

# Only nccl.h and nccl_net.h are public headers and only they are installed!
set(INCEXPORTS
    ${CONFIGURED_HEADERS_DIR}/nccl.h
    ${CMAKE_CURRENT_SOURCE_DIR}/include/plugin/nccl_net.h
    PARENT_SCOPE
)
# === @end: nccl library ===


# === @begin: ras/ ===
add_subdirectory(ras)
# === @end: ras/ ===
